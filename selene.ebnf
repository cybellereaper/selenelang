(* ----------------- LEXICAL ----------------- *)

identifier      = letter , { letter | digit | "_" } ;
letter          = "A".."Z" | "a".."z" | "_" ;
digit           = "0".."9" ;

number          = digit , { digit } , [ "." , digit , { digit } ] ;
string_literal  = '"' , { character - '"' } , '"' | '"""' , { character } , '"""' ;
format_string   = "f\"" , { character - '"' } , '"' | "f\"\"\"" , { character } , "\"\"\"" ;
raw_string      = "`" , { character - "`" } , "`" | "r\"" , { character - '"' } , '"'
                | "r\"\"\"" , { character } , "\"\"\"" ;
boolean         = "true" | "false" ;
null            = "null" ;

(* ----------------- PROGRAM STRUCTURE ----------------- *)

program         = [ package_decl ] , { top_level_item } ;

top_level_item  = module_decl | declaration | statement ;

package_decl    = "package" , identifier , [ ";" ] ;

module_decl     = "module" , identifier , block ;

import_decl     = "import" , (
                    identifier , string_literal , [ "as" , identifier ]
                  | import_path , [ "as" , identifier ]
                 ) , ";" ;

import_path     = identifier , { "." , identifier } | string_literal ;

(* ----------------- DECLARATIONS ----------------- *)

declaration     = variable_decl | function_decl | extension_decl | class_decl
                | struct_decl | enum_decl | interface_decl | contract_decl | import_decl ;

statement       = declaration | flow_stmt | block | expression_stmt ;

flow_stmt       = match_stmt | if_stmt | while_stmt | for_stmt | using_stmt | try_stmt
                | throw_stmt | return_stmt | break_stmt | continue_stmt | condition_stmt ;

expression_stmt = expression , [ ";" ] ;

block           = "{" , { statement } , "}" ;

variable_decl   = ("let" | "var") , identifier , [ ":" , type ] , "=" , expression , ";" ;

function_decl   = "fn" , identifier , [ type_param_list ] , parameter_clause , [ return_type ]
                , [ "async" ] , [ contract_block ] , function_body ;

extension_decl  = "ext" , "fn" , type , "." , identifier , [ type_param_list ]
                , parameter_clause , [ return_type ] , [ "async" ] , [ contract_block ]
                , function_body ;

parameter_clause= "(" , [ param_list ] , ")" ;
return_type     = ":" , type ;

param_list      = param , { "," , param } ;
param           = identifier , ":" , type ;

type_param_list = "<" , identifier , { "," , identifier } , ">" ;

function_body   = block | ( "=" | "=>" ) , expression , [ ";" ] ;

contract_block  = "contract" , "{" , { contract_clause } , "}" ;
contract_clause = "returns" , "(" , [ expression ] , ")" , "=>" , expression , ";" ;

type            = identifier , [ "<" , type , { "," , type } , ">" ] , [ "?" ] ;

class_decl      = "class" , identifier , parameter_clause , [ ":" , identifier ] , [ block ] ;
struct_decl     = "struct" , identifier , parameter_clause , [ block ] ;

enum_decl       = "enum" , identifier , [ type_param_list ] , "{" , { enum_case } , "}" ;

enum_case       = identifier , [ "(" , [ param_list ] , ")" ] , ";" ;

interface_decl  = "interface" , identifier , "{" , { interface_member } , "}" ;
interface_member= "fn" , identifier , parameter_clause , [ return_type ] , ";" ;

contract_decl   = "contract" , identifier , block ;

(* ----------------- CONTROL FLOW ----------------- *)

if_stmt         = "if" , expression , block , [ "else" , statement ] ;

while_stmt      = "while" , expression , block ;

for_stmt        = "for" , "(" , [ for_init ] , ";" , [ expression ] , ";" , [ expression ] , ")" , block ;
for_init        = variable_binding | expression ;
variable_binding= ("let" | "var") , identifier , [ ":" , type ] , "=" , expression ;

using_stmt      = "using" , [ identifier , "=" ] , expression , block ;

try_stmt        = "try" , block , [ catch_clause ] , [ finally_clause ] ;
catch_clause    = "catch" , [ "(" , [ identifier ] , ")" ] , block ;
finally_clause  = "finally" , block ;

throw_stmt      = "throw" , expression , [ ";" ] ;
return_stmt     = "return" , [ expression ] , [ ";" ] ;
break_stmt      = "break" , [ ";" ] ;
continue_stmt   = "continue" , [ ";" ] ;

condition_stmt  = "condition" , "{" , { condition_clause } , [ condition_else ] , "}" ;
condition_clause= "when" , expression , "=>" , block ;
condition_else  = "else" , "=>" , block ;

(* ----------------- MATCH ----------------- *)

match_stmt      = "match" , expression , "{" , { pattern , "=>" , statement } , "}" ;

pattern         = literal_pattern | identifier | struct_pattern | object_pattern ;

literal_pattern = number | string_literal | format_string | raw_string | boolean | "null" ;

struct_pattern  = identifier , "(" , [ pattern , { "," , pattern } ] , ")" ;
object_pattern  = "{" , [ pair_pattern , { "," , pair_pattern } ] , "}" ;
pair_pattern    = ( string_literal | identifier ) , ":" , pattern ;

(* ----------------- EXPRESSIONS ----------------- *)

expression      = assignment ;

assignment      = conditional , [ assignment_operator , expression ] ;
assignment_operator = "=" | "+=" | "-=" | "*=" | "/=" | "%=" ;

conditional     = logical_or , [ "?:" , expression ] ;

logical_or      = logical_and , { "||" , logical_and } ;
logical_and     = equality , { "&&" , equality } ;

equality        = comparison , { ("==" | "!=") , comparison } ;
comparison      = additive , { ("<" | "<=" | ">" | ">=" | "is" | "!is") , additive } ;

additive        = multiplicative , { ("+" | "-") , multiplicative } ;
multiplicative  = unary , { ("*" | "/" | "%") , unary } ;

unary           = ( "!" | "-" | "&" | "*" ) , unary | postfix ;

postfix         = primary , { postfix_part } ;
postfix_part    = "." , identifier | "?." , identifier | "[" , expression , "]"
                | "!!" | "(" , [ argument_list ] , ")" ;

argument_list   = expression , { "," , expression } ;

primary         = number | string_literal | format_string | raw_string | boolean | "null"
                | identifier | array_literal | object_literal | await_expr
                | "(" , expression , ")" ;

array_literal   = "[" , [ expression , { "," , expression } ] , "]" ;
object_literal  = "{" , [ pair , { "," , pair } ] , "}" ;
pair            = ( string_literal | identifier ) , ":" , expression ;

await_expr      = "await" , expression ;
