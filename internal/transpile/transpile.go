// Package transpile converts Selene programs into Go source code.
package transpile

import (
	"fmt"
	"maps"
	"slices"
	"sort"
	"strconv"
	"strings"

	"github.com/cybellereaper/selenelang/internal/ast"
	"github.com/cybellereaper/selenelang/internal/token"
)

// ToGo converts a Selene program into Go source code.
func ToGo(program *ast.Program) (string, error) {
	pkgName := "main"
	imports := make(map[string]string)
	items := make([]ast.ProgramItem, 0, len(program.Items))
	for _, item := range program.Items {
		switch node := item.(type) {
		case *ast.PackageDeclaration:
			if node.Name != nil && node.Name.Name != "" {
				pkgName = node.Name.Name
			}
		case *ast.ImportDeclaration:
			path := node.PathLiteral
			if path == "" {
				parts := make([]string, len(node.Path))
				for i, seg := range node.Path {
					parts[i] = seg.Name
				}
				path = strings.Join(parts, "/")
			}
			alias := ""
			if node.Alias != nil {
				alias = node.Alias.Name
			}
			imports[path] = alias
		default:
			items = append(items, item)
		}
	}

	emitter := &goEmitter{}
	emitter.writeLine("// Code generated by selene transpile. DO NOT EDIT.")
	emitter.writeLine(fmt.Sprintf("package %s", pkgName))
	emitter.writeLine("")

	if len(imports) > 0 {
		emitter.writeLine("import (")
		emitter.indent++
		paths := slices.Collect(maps.Keys(imports))
		sort.Strings(paths)
		for _, path := range paths {
			alias := imports[path]
			if alias != "" {
				emitter.writeLine(fmt.Sprintf("%s \"%s\"", alias, path))
			} else {
				emitter.writeLine(fmt.Sprintf("\"%s\"", path))
			}
		}
		emitter.indent--
		emitter.writeLine(")")
		emitter.writeLine("")
	}

	for _, item := range items {
		emitter.emitProgramItem(item)
	}

	if emitter.usesElvis {
		emitter.ensureBlankLine()
		emitter.writeLine("func seleneElvis(left, right any) any {")
		emitter.indent++
		emitter.writeLine("if left != nil {")
		emitter.indent++
		emitter.writeLine("return left")
		emitter.indent--
		emitter.writeLine("}")
		emitter.writeLine("return right")
		emitter.indent--
		emitter.writeLine("}")
	}

	if emitter.needsHelper {
		emitter.ensureBlankLine()
		emitter.writeLine("func seleneUnsupported(feature string) any {")
		emitter.indent++
		emitter.writeLine("panic(\"selene transpiler: unsupported \" + feature)")
		emitter.indent--
		emitter.writeLine("}")
	}

	out := strings.TrimRight(emitter.builder.String(), "\n") + "\n"
	return out, nil
}

type goEmitter struct {
	builder     strings.Builder
	indent      int
	needsHelper bool
	usesElvis   bool
	lastBlank   bool
}

func (e *goEmitter) writeLine(parts ...string) {
	line := strings.Join(parts, "")
	if line == "" {
		e.builder.WriteByte('\n')
		e.lastBlank = true
		return
	}
	for i := 0; i < e.indent; i++ {
		e.builder.WriteByte('\t')
	}
	e.builder.WriteString(line)
	e.builder.WriteByte('\n')
	e.lastBlank = false
}

func (e *goEmitter) ensureBlankLine() {
	if e.builder.Len() == 0 {
		return
	}
	if e.lastBlank {
		return
	}
	e.builder.WriteByte('\n')
	e.lastBlank = true
}

func (e *goEmitter) emitProgramItem(item ast.ProgramItem) {
	switch node := item.(type) {
	case ast.Statement:
		e.emitStatement(node)
	case *ast.ModuleDeclaration:
		name := "module"
		if node.Name != nil {
			name = node.Name.Name
		}
		e.writeLine(fmt.Sprintf("// module %s requires manual translation", name))
	default:
		e.unsupportedStmt(fmt.Sprintf("program item %T", item))
	}
	e.ensureBlankLine()
}

func (e *goEmitter) emitStatements(stmts []ast.Statement) {
	for _, stmt := range stmts {
		e.emitStatement(stmt)
	}
}

func (e *goEmitter) emitStatement(stmt ast.Statement) {
	switch node := stmt.(type) {
	case *ast.FunctionDeclaration:
		e.emitFunction(node)
	case *ast.VariableDeclaration:
		name := "value"
		if node.Name != nil && node.Name.Name != "" {
			name = node.Name.Name
		}
		if node.Value != nil {
			e.writeLine(fmt.Sprintf("var %s any = %s", name, e.expression(node.Value)))
		} else {
			e.writeLine(fmt.Sprintf("var %s any", name))
		}
	case *ast.ExpressionStatement:
		if node.Expression != nil {
			e.writeLine(e.expression(node.Expression))
		}
	case *ast.BlockStatement:
		e.writeLine("{")
		e.indent++
		e.emitStatements(node.Statements)
		e.indent--
		e.writeLine("}")
	case *ast.ReturnStatement:
		if node.Value != nil {
			e.writeLine("return ", e.expression(node.Value))
		} else {
			e.writeLine("return")
		}
	case *ast.IfStatement:
		e.writeLine("if ", e.expression(node.Condition), " {")
		e.indent++
		e.emitBranch(node.Consequence)
		e.indent--
		e.writeLine("}")
		if node.Alternative != nil {
			e.writeLine("else {")
			e.indent++
			e.emitBranch(node.Alternative)
			e.indent--
			e.writeLine("}")
		}
	case *ast.WhileStatement:
		cond := "true"
		if node.Condition != nil {
			cond = e.expression(node.Condition)
		}
		e.writeLine("for ", cond, " {")
		e.indent++
		e.emitBranch(node.Body)
		e.indent--
		e.writeLine("}")
	case *ast.ForStatement:
		init := e.forInit(node.Init)
		cond := ""
		if node.Condition != nil {
			cond = e.expression(node.Condition)
		}
		post := ""
		if node.Post != nil {
			post = e.expression(node.Post)
		}
		e.writeLine("for ", init, "; ", cond, "; ", post, " {")
		e.indent++
		e.emitBranch(node.Body)
		e.indent--
		e.writeLine("}")
	case *ast.BreakStatement:
		e.writeLine("break")
	case *ast.ContinueStatement:
		e.writeLine("continue")
	default:
		e.unsupportedStmt(fmt.Sprintf("statement %T", stmt))
	}
}

func (e *goEmitter) emitBranch(stmt ast.Statement) {
	if stmt == nil {
		return
	}
	if block, ok := stmt.(*ast.BlockStatement); ok {
		e.emitStatements(block.Statements)
		return
	}
	e.emitStatement(stmt)
}

func (e *goEmitter) emitFunction(fn *ast.FunctionDeclaration) {
	name := "fn"
	if fn.Name != nil && fn.Name.Name != "" {
		name = fn.Name.Name
	}
	params := make([]string, 0, len(fn.Params)+1)
	if fn.IsExtension && fn.Receiver != nil && fn.Receiver.Name != nil {
		recv := strings.ToLower(fn.Receiver.Name.Name[:1]) + fn.Receiver.Name.Name[1:]
		params = append(params, fmt.Sprintf("%s any", recv))
	}
	for i, param := range fn.Params {
		pname := fmt.Sprintf("arg%d", i)
		if param.Name != nil && param.Name.Name != "" {
			pname = param.Name.Name
		}
		params = append(params, fmt.Sprintf("%s any", pname))
	}
	signature := fmt.Sprintf("func %s(%s)", name, strings.Join(params, ", "))
	if fn.ReturnType != nil {
		signature += " " + e.goTypeName(fn.ReturnType)
	} else if fn.IsExprBody || fn.Body == nil {
		signature += " any"
	}
	e.writeLine(signature + " {")
	e.indent++
	if fn.IsExprBody {
		if fn.BodyExpr != nil {
			e.writeLine("return ", e.expression(fn.BodyExpr))
		} else {
			e.writeLine("return nil")
		}
	} else if fn.Body != nil {
		e.emitStatements(fn.Body.Statements)
	} else {
		e.writeLine("return nil")
	}
	e.indent--
	e.writeLine("}")
}

func (e *goEmitter) goTypeName(t *ast.TypeAnnotation) string {
	if t == nil || t.Name == nil {
		return "any"
	}
	return t.Name.Name
}

func (e *goEmitter) forInit(stmt ast.Statement) string {
	if stmt == nil {
		return ""
	}
	switch node := stmt.(type) {
	case *ast.VariableDeclaration:
		name := "value"
		if node.Name != nil && node.Name.Name != "" {
			name = node.Name.Name
		}
		if node.Value != nil {
			return fmt.Sprintf("var %s any = %s", name, e.expression(node.Value))
		}
		return fmt.Sprintf("var %s any", name)
	case *ast.ExpressionStatement:
		return e.expression(node.Expression)
	default:
		e.needsHelper = true
		return "seleneUnsupported(\"for-init\")"
	}
}

func (e *goEmitter) unsupportedStmt(feature string) {
	e.needsHelper = true
	e.writeLine("_ = seleneUnsupported(\"", feature, "\")")
}

func (e *goEmitter) expression(expr ast.Expression) string {
	switch node := expr.(type) {
	case *ast.Identifier:
		return node.Name
	case *ast.NumberLiteral:
		return node.Value
	case *ast.StringLiteral:
		return strconv.Quote(node.Value)
	case *ast.BooleanLiteral:
		if node.Value {
			return "true"
		}
		return "false"
	case *ast.NullLiteral:
		return "nil"
	case *ast.ArrayLiteral:
		parts := make([]string, 0, len(node.Elements))
		for _, el := range node.Elements {
			parts = append(parts, e.expression(el))
		}
		return "[]any{" + strings.Join(parts, ", ") + "}"
	case *ast.ObjectLiteral:
		pairs := make([]string, 0, len(node.Pairs))
		for _, pair := range node.Pairs {
			pairs = append(pairs, strconv.Quote(pair.Key)+": "+e.expression(pair.Value))
		}
		return "map[string]any{" + strings.Join(pairs, ", ") + "}"
	case *ast.PrefixExpression:
		return fmt.Sprintf("(%s%s)", node.Operator, e.expression(node.Right))
	case *ast.InfixExpression:
		return fmt.Sprintf("(%s %s %s)", e.expression(node.Left), mapOperator(node.Operator), e.expression(node.Right))
	case *ast.AssignmentExpression:
		target := e.expression(node.Target)
		value := e.expression(node.Value)
		if node.Operator == token.ASSIGN {
			return fmt.Sprintf("%s = %s", target, value)
		}
		if op, ok := augmentedOperator(node.Operator); ok {
			return fmt.Sprintf("%s = %s %s %s", target, target, op, value)
		}
		e.needsHelper = true
		return "seleneUnsupported(\"assignment\")"
	case *ast.CallExpression:
		args := make([]string, 0, len(node.Arguments))
		for _, arg := range node.Arguments {
			args = append(args, e.expression(arg))
		}
		return fmt.Sprintf("%s(%s)", e.expression(node.Callee), strings.Join(args, ", "))
	case *ast.IndexExpression:
		return fmt.Sprintf("%s[%s]", e.expression(node.Collection), e.expression(node.Index))
	case *ast.MemberExpression:
		if node.Optional {
			e.needsHelper = true
			return "seleneUnsupported(\"optional access\")"
		}
		return fmt.Sprintf("%s.%s", e.expression(node.Object), node.Property)
	case *ast.ElvisExpression:
		e.usesElvis = true
		return fmt.Sprintf("seleneElvis(%s, %s)", e.expression(node.Left), e.expression(node.Right))
	case *ast.AwaitExpression:
		e.needsHelper = true
		return "seleneUnsupported(\"await\")"
	case *ast.NonNullAssertion:
		return e.expression(node.Expression)
	default:
		e.needsHelper = true
		return fmt.Sprintf("seleneUnsupported(\"expression %T\")", expr)
	}
}

func mapOperator(op string) string {
	switch op {
	case "is":
		return "=="
	case "!is":
		return "!="
	default:
		return op
	}
}

func augmentedOperator(op token.Type) (string, bool) {
	switch op {
	case token.PLUS_ASSIGN:
		return "+", true
	case token.MINUS_ASSIGN:
		return "-", true
	case token.STAR_ASSIGN:
		return "*", true
	case token.SLASH_ASSIGN:
		return "/", true
	case token.PERCENT_ASSIGN:
		return "%", true
	}
	return "", false
}
